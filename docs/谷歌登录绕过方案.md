# Electron 应用绕过 Google 登录检测解决方案

## 问题描述

在 Electron 应用中通过 `<webview>` 标签访问 Google 服务（如 Gemini、ChatGPT 的 Google 登录）时，可能会遇到以下错误提示：

> **"此浏览器或应用可能不安全"**
> (This browser or app may not be secure)

这是因为 Google 的反欺诈系统检测到了非标准浏览器环境（Electron/Chromium 内核但非标准 Chrome）。

## 解决方案核心原理

要绕过此检测，必须在 **网络层** 和 **JavaScript 执行环境层** 同时进行深度伪装，确保两者表现出的特征完全一致，且不包含 Electron 的特征。

### 1. 网络层 (Main Process)
*   **User-Agent 伪装**：强制将所有发往 Google 的请求头的 `User-Agent` 替换为标准的、最新版的 Chrome UA。
*   **Client Hints 伪造**：Electron 默认会发送带有 "Electron" 标识的 Hints，必须将其替换为标准 Chrome 的 Hints，否则如果它与伪装的 UA 不匹配，会被立即识别。

### 2. JS 环境层 (Preload Script)
*   **Navigator 对象覆盖**：在页面加载前（Preload 阶段），通过 `Object.defineProperty` 覆盖 `navigator.userAgent`，使其与网络层的 UA **完全一致**。
*   **Client Hints API 模拟**：覆盖 `navigator.userAgentData`，使其返回与 UA 一致的版本信息（如 Chrome 131）。
*   **特征隐藏**：移除 `navigator.webdriver`、`cdc_` 等自动化测试工具留下的标记。
*   **环境模拟**：Mock `window.chrome`、`navigator.plugins` 等对象，使其更像真实的 Chrome 浏览器。

---

## 具体实现步骤

### 第一步：主进程拦截 (src/utils/common.ts)

在主进程中实现 `fixGoogleLogin` 函数，并在 `app.on('ready')` 中调用。

```typescript
// src/utils/common.ts
import { session } from 'electron'

/**
 * 修复 Google 登录时的 "此浏览器或应用可能不安全" 提示
 * @param {string} [partition] - Webview 的 partition 属性值，例如 'persist:webview'。如果未使用 partition，请传 undefined 或 null。
 */
export async function fixGoogleLogin(partition?: string) {
  const ses = partition
    ? session.fromPartition(partition)
    : session.defaultSession

  // 清除缓存和存储，确保干净的登录环境（可选，如果用户反馈登录循环可开启）
  await ses.clearStorageData()

  // 1. 获取原始 UA
  const originalUA = ses.getUserAgent()

  // 2. 清洗 UA：移除 Electron 和 应用名称，保留 Chrome/Safari 版本
  // 或者直接使用硬编码的 Chrome UA，这通常更稳妥
  const cleanUA =
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'

  // 3. 设置全局 UA
  ses.setUserAgent(cleanUA)

  // 4. 强制拦截 Google 相关请求，确保 UA 绝对干净，并处理 Client Hints
  const filter = {
    urls: [
      '*://*.google.com/*',
      '*://accounts.google.com/*'
    ]
  }

  ses.webRequest.onBeforeSendHeaders(
    filter,
    (details, callback) => {
      try {
        const { requestHeaders } = details
        // console.log('Intercepting request:', details.url)

        // 使用最新的 Chrome UA
        const chromeUA =
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'
        requestHeaders['User-Agent'] = chromeUA

        // 伪造 Client Hints 以匹配 UA
        requestHeaders['sec-ch-ua'] =
          '"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"'
        requestHeaders['sec-ch-ua-mobile'] = '?0'
        requestHeaders['sec-ch-ua-platform'] = '"macOS"'

        // 移除可能暴露的完整版本信息
        delete requestHeaders['sec-ch-ua-full-version']
        delete requestHeaders['sec-ch-ua-full-version-list']

        callback({ requestHeaders })
      } catch (e) {
        console.error('Error in webRequest interceptor:', e)
        callback({ requestHeaders: details.requestHeaders })
      }
    }
  )
}
```

### 第二步：Preload 脚本注入 (src/webview-preload.ts)

在 `<webview>` 的 preload 脚本中注入反检测代码。**关键点是 UA 和 userAgentData 必须与主进程完全一致。**

```typescript
// src/webview-preload.ts

// 移除 webdriver 属性，绕过 Cloudflare 检测
try {
  const code = `
    // 0. 移除 Selenium/ChromeDriver 标记 (cdc_...)
    // 这些通常被检测脚本使用。
    for (const key in window) {
      if (key.startsWith('cdc_')) {
        delete window[key];
      }
    }

    // 1. 通过 Webdriver 检测
    // 如果 disable-blink-features=AutomationControlled 标志因某种原因未生效，
    // 或者有其他机制设置了它，我们确保将其移除。
    if ('webdriver' in navigator) {
      delete Object.getPrototypeOf(navigator).webdriver;
      delete navigator.webdriver;
    }
    
    // 2. 如果插件列表为空，则模拟插件
    if (navigator.plugins.length === 0) {
      const pdfPlugin = {
        0: { type: "application/x-google-chrome-pdf", suffixes: "pdf", description: "Portable Document Format", enabledPlugin: null },
        description: "Portable Document Format",
        filename: "internal-pdf-viewer",
        length: 1,
        name: "Chrome PDF Plugin"
      };
      // 修复 enabledPlugin 的循环引用
      pdfPlugin[0].enabledPlugin = pdfPlugin;
      
      const plugins = [pdfPlugin, pdfPlugin, pdfPlugin]; // 为简洁起见进行了简化，通常是不同的
      // 最好让它看起来像一个 PluginArray
      const pluginArray = {
        0: pdfPlugin,
        1: pdfPlugin,
        2: pdfPlugin,
        length: 3,
        item: (index) => plugins[index],
        namedItem: (name) => plugins.find(p => p.name === name),
        refresh: () => {}
      };
      
      Object.defineProperty(navigator, 'plugins', {
        get: () => pluginArray,
        configurable: true
      });
    }

    // 3. 确保 languages 属性存在
    if (!navigator.languages || navigator.languages.length === 0) {
      Object.defineProperty(navigator, 'languages', {
        get: () => ['zh-CN', 'zh', 'en'],
        configurable: true
      });
    }

    // 4. WebGL 供应商/渲染器
    const getParameter = WebGLRenderingContext.getParameter;
    WebGLRenderingContext.prototype.getParameter = function(parameter) {
      // UNMASKED_VENDOR_WEBGL
      if (parameter === 37445) {
        return 'Intel Inc.';
      }
      // UNMASKED_RENDERER_WEBGL
      if (parameter === 37446) {
        return 'Intel(R) Iris(R) Plus Graphics 640';
      }
      return getParameter(parameter);
    };

    // 5. 模拟 window.chrome
    if (!window.chrome) {
      const chromeMock = {
        runtime: {
          connect: () => {},
          sendMessage: () => {},
          onMessage: { addListener: () => {}, removeListener: () => {} }
        },
        loadTimes: () => {},
        csi: () => {},
        app: {
          isInstalled: false,
          InstallState: {
            DISABLED: 'disabled',
            INSTALLED: 'installed',
            NOT_INSTALLED: 'not_installed'
          },
          RunningState: {
            CANNOT_RUN: 'cannot_run',
            READY_TO_RUN: 'ready_to_run',
            RUNNING: 'running'
          }
        }
      };
      Object.defineProperty(window, 'chrome', {
        get: () => chromeMock,
        configurable: true
      });
    }

    // 6. 模拟 navigator.permissions
    if (navigator.permissions) {
      const originalQuery = navigator.permissions.query;
      navigator.permissions.query = (parameters) => (
        parameters.name === 'notifications' ?
          Promise.resolve({ state: Notification.permission, onchange: null }) :
          originalQuery(parameters)
      );
    }

    // 7. 确保主世界中的 User-Agent 一致性
    // 使用与 main.ts 中相同的硬编码 UA
    // 注意：我们在这里硬编码以避免预加载脚本中的导入问题
    const newUA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';
    
    Object.defineProperty(navigator, 'userAgent', {
      get: () => newUA,
      configurable: true
    });

    // 8. 模拟 navigator.userAgentData
    // 这一点至关重要，因为 Google 使用它来检测真实的 Chromium 版本（例如 136）
    // 这与我们伪造的 UA (131) 不匹配。
    if (navigator.userAgentData) {
      const brands = [
        { brand: 'Not_A Brand', version: '24' },
        { brand: 'Chromium', version: '131' },
        { brand: 'Google Chrome', version: '131' }
      ];
      
      Object.defineProperty(navigator, 'userAgentData', {
        get: () => ({
          brands: brands,
          mobile: false,
          platform: 'macOS',
          getHighEntropyValues: (hints) => Promise.resolve({
            brands: brands,
            mobile: false,
            platform: 'macOS',
            architecture: 'x86',
            bitness: '64',
            model: '',
            platformVersion: '14.0.0',
            uaFullVersion: '131.0.0.0',
            fullVersionList: brands
          })
        }),
        configurable: true
      });
    }

    // 9. 模拟 maxTouchPoints
    Object.defineProperty(navigator, 'maxTouchPoints', {
      get: () => 0,
      configurable: true
    });
  `

  const inject = () => {
    const doc = document.head || document.documentElement
    if (doc) {
      try {
        const script = document.createElement('script')
        script.textContent = code
        doc.appendChild(script)
        script.remove()
      } catch (e) {
        // silent fail
      }
    } else {
      setTimeout(inject, 10)
    }
  }

  inject()
} catch (e) {
  // silent fail
}
```

### 第三步：命令行开关 (src/main.ts)

在应用启动时添加命令行开关，禁用自动化控制特征。

```typescript
// src/main.ts
app.commandLine.appendSwitch('ignore-certificate-errors')
app.commandLine.appendSwitch('disable-blink-features', 'AutomationControlled')
app.commandLine.appendSwitch('disable-features', 'WebGPU,WebAuthn')
// 禁用 QUIC 协议，解决代理环境下 Google 服务连接不稳定/SSL 握手失败的问题
app.commandLine.appendSwitch('disable-quic')
// 防止后台窗口被节流，解决隐藏后再打开白屏的问题
app.commandLine.appendSwitch('disable-backgrounding-occluded-windows', 'true')
```

## 调试技巧

1.  **开启开发者工具**：
    *   主窗口：`browserWindow.webContents.openDevTools()`
    *   Webview：`webview.openDevTools()`
2.  **检查 Network**：
    *   在 Webview 的开发者工具中，查看 `accounts.google.com` 的请求头。
    *   确认 `User-Agent` 是 `Chrome/131.0.0.0`。
    *   确认 `sec-ch-ua` 是 `"Google Chrome";v="131"...`。
3.  **检查 Console**：
    *   在 Console 中输入 `navigator.userAgent`，确认输出与请求头一致。
    *   输入 `navigator.userAgentData.brands`，确认包含 `Google Chrome v131`。
    *   输入 `navigator.webdriver`，确认返回 `undefined` 或 `false`。

## 常见问题

*   **依然提示不安全？**
    *   尝试清除缓存：`session.defaultSession.clearStorageData()`。
    *   检查 `webview-preload.ts` 中的 UA 字符串是否与 `src/utils/common.ts` 中的完全一致（包括标点符号）。
    *   检查 `userAgentData` 中的版本号是否与 UA 字符串中的版本号一致。
