# Electron 应用绕过 Google 登录检测解决方案

## 问题描述

在 Electron 应用中通过 `<webview>` 标签访问 Google 服务（如 Gemini、ChatGPT 的 Google 登录）时，可能会遇到以下错误提示：

> **"此浏览器或应用可能不安全"**
> (This browser or app may not be secure)

这是因为 Google 的反欺诈系统检测到了非标准浏览器环境（Electron/Chromium 内核但非标准 Chrome）。

## 解决方案核心原理

要绕过此检测，必须在 **网络层** 和 **JavaScript 执行环境层** 同时进行深度伪装，确保两者表现出的特征完全一致，且不包含 Electron 的特征。

### 1. 网络层 (Main Process)
*   **User-Agent 伪装**：强制将所有发往 Google 的请求头的 `User-Agent` 替换为标准的、最新版的 Chrome UA。
*   **Client Hints 伪造**：Electron 默认会发送带有 "Electron" 标识的 Hints，必须将其替换为标准 Chrome 的 Hints，否则如果它与伪装的 UA 不匹配，会被立即识别。

### 2. JS 环境层 (Preload Script)
*   **Navigator 对象覆盖**：在页面加载前（Preload 阶段），通过 `Object.defineProperty` 覆盖 `navigator.userAgent`，使其与网络层的 UA **完全一致**。
*   **Client Hints API 模拟**：覆盖 `navigator.userAgentData`，使其返回与 UA 一致的版本信息（如 Chrome 131）。
*   **特征隐藏**：移除 `navigator.webdriver`、`cdc_` 等自动化测试工具留下的标记。
*   **环境模拟**：Mock `window.chrome`、`navigator.plugins` 等对象，使其更像真实的 Chrome 浏览器。

---

## 具体实现步骤

### 第一步：主进程拦截 (src/utils/common.ts)

在主进程中实现 `fixGoogleLogin` 函数，并在 `app.on('ready')` 中调用。

```typescript
// src/utils/common.ts
import { session } from 'electron'

export async function fixGoogleLogin(partition?: string) {
  const ses = partition
    ? session.fromPartition(partition)
    : session.defaultSession

  // 清除缓存和存储，确保干净的登录环境
  await ses.clearStorageData()

  // 1. 设置全局 UA (基础伪装)
  const cleanUA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
  ses.setUserAgent(cleanUA)

  // 2. 强制拦截 Google 相关请求，确保 UA 绝对干净，并处理 Client Hints
  const filter = {
    urls: [
      '*://*.google.com/*',
      '*://accounts.google.com/*'
    ]
  }

  ses.webRequest.onBeforeSendHeaders(
    filter,
    (details, callback) => {
      try {
        const { requestHeaders } = details

        // 使用最新的 Chrome UA (Chrome 131)
        const chromeUA =
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'
        requestHeaders['User-Agent'] = chromeUA

        // 伪造 Client Hints 以匹配 UA
        // 这是关键：如果 UA 是 Chrome 131 但 Hints 是 Electron，会被立即检测到
        requestHeaders['sec-ch-ua'] =
          '"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"'
        requestHeaders['sec-ch-ua-mobile'] = '?0'
        requestHeaders['sec-ch-ua-platform'] = '"macOS"'

        // 移除可能暴露的完整版本信息
        delete requestHeaders['sec-ch-ua-full-version']
        delete requestHeaders['sec-ch-ua-full-version-list']

        callback({ requestHeaders })
      } catch (e) {
        console.error('Error in webRequest interceptor:', e)
        callback({ requestHeaders: details.requestHeaders })
      }
    }
  )
}
```

### 第二步：Preload 脚本注入 (src/webview-preload.ts)

在 `<webview>` 的 preload 脚本中注入反检测代码。**关键点是 UA 和 userAgentData 必须与主进程完全一致。**

```typescript
// src/webview-preload.ts

// 移除 webdriver 属性，绕过 Cloudflare 检测
try {
  const code = `
    // 0. 移除 Selenium/ChromeDriver 标记 (cdc_...)
    for (const key in window) {
      if (key.startsWith('cdc_')) {
        delete window[key];
      }
    }

    // 1. 通过 Webdriver 检测
    if ('webdriver' in navigator) {
      delete Object.getPrototypeOf(navigator).webdriver;
      delete navigator.webdriver;
    }
    
    // 2. 如果插件列表为空，则模拟插件
    if (navigator.plugins.length === 0) {
      // ... (模拟 Chrome PDF Plugin)
    }

    // 3. 确保 languages 属性存在
    if (!navigator.languages || navigator.languages.length === 0) {
      Object.defineProperty(navigator, 'languages', {
        get: () => ['zh-CN', 'zh', 'en'],
        configurable: true
      });
    }

    // 4. WebGL 供应商/渲染器 (模拟 Intel 显卡)
    const getParameter = WebGLRenderingContext.getParameter;
    WebGLRenderingContext.prototype.getParameter = function(parameter) {
      if (parameter === 37445) return 'Intel Inc.';
      if (parameter === 37446) return 'Intel(R) Iris(R) Plus Graphics 640';
      return getParameter(parameter);
    };

    // 5. 模拟 window.chrome
    if (!window.chrome) {
      // ... (模拟 chrome.runtime, chrome.app 等)
    }

    // 6. 模拟 navigator.permissions
    if (navigator.permissions) {
      // ...
    }

    // 7. 确保主世界中的 User-Agent 一致性
    // 必须使用与 main.ts 中完全相同的字符串！
    const newUA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';
    
    Object.defineProperty(navigator, 'userAgent', {
      get: () => newUA,
      configurable: true
    });

    // 8. 模拟 navigator.userAgentData
    // 这一点至关重要，因为 Google 使用它来检测真实的 Chromium 版本
    if (navigator.userAgentData) {
      const brands = [
        { brand: 'Not_A Brand', version: '24' },
        { brand: 'Chromium', version: '131' },
        { brand: 'Google Chrome', version: '131' }
      ];
      
      Object.defineProperty(navigator, 'userAgentData', {
        get: () => ({
          brands: brands,
          mobile: false,
          platform: 'macOS',
          getHighEntropyValues: (hints) => Promise.resolve({
            brands: brands,
            mobile: false,
            platform: 'macOS',
            architecture: 'x86',
            bitness: '64',
            model: '',
            platformVersion: '14.0.0',
            uaFullVersion: '131.0.0.0',
            fullVersionList: brands
          })
        }),
        configurable: true
      });
    }

    // 9. 模拟 maxTouchPoints
    Object.defineProperty(navigator, 'maxTouchPoints', {
      get: () => 0,
      configurable: true
    });
  `

  const inject = () => {
    const doc = document.head || document.documentElement
    if (doc) {
      try {
        const script = document.createElement('script')
        script.textContent = code
        doc.appendChild(script)
        script.remove()
      } catch (e) {
        // silent fail
      }
    } else {
      setTimeout(inject, 10)
    }
  }

  inject()
} catch (e) {
  // silent fail
}
```

### 第三步：命令行开关 (src/main.ts)

在应用启动时添加命令行开关，禁用自动化控制特征。

```typescript
// src/main.ts
app.commandLine.appendSwitch('disable-blink-features', 'AutomationControlled')
```

## 调试技巧

1.  **开启开发者工具**：
    *   主窗口：`browserWindow.webContents.openDevTools()`
    *   Webview：`webview.openDevTools()`
2.  **检查 Network**：
    *   在 Webview 的开发者工具中，查看 `accounts.google.com` 的请求头。
    *   确认 `User-Agent` 是 `Chrome/131.0.0.0`。
    *   确认 `sec-ch-ua` 是 `"Google Chrome";v="131"...`。
3.  **检查 Console**：
    *   在 Console 中输入 `navigator.userAgent`，确认输出与请求头一致。
    *   输入 `navigator.userAgentData.brands`，确认包含 `Google Chrome v131`。
    *   输入 `navigator.webdriver`，确认返回 `undefined` 或 `false`。

## 常见问题

*   **依然提示不安全？**
    *   尝试清除缓存：`session.defaultSession.clearStorageData()`。
    *   检查 `webview-preload.ts` 中的 UA 字符串是否与 `src/utils/common.ts` 中的完全一致（包括标点符号）。
    *   检查 `userAgentData` 中的版本号是否与 UA 字符串中的版本号一致。
